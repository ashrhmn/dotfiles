#!/bin/bash

set -e

VERSION="1.0.0"

usage() {
    cat << EOF
Usage: pgc [OPTIONS] [SQL_COMMAND | -- PSQL_ARGS...]

Connect to PostgreSQL using environment variables from .env file

Options:
    -e, --env-file <file>    Specify custom .env file (default: .env)
    --no-env                Skip .env file and use shell environment variables
    -d, --debug             Show debug output for connection variables
    -h, --help              Show this help message
    -v, --version           Show version information

Environment Variables (in priority order):
    URL:      DATABASE_URL, DB_URL, POSTGRES_URL, POSTGRESQL_URL, PG_URL
    Host:     DATABASE_HOST, DB_HOST, POSTGRES_HOST, PG_HOST, PGHOST
    Port:     DATABASE_PORT, DB_PORT, POSTGRES_PORT, PG_PORT, PGPORT
    User:     DATABASE_USERNAME, DATABASE_USER, DB_USER, DB_USERNAME, POSTGRES_USER, PG_USER, PGUSER
    Password: DATABASE_PASSWORD, DB_PASSWORD, POSTGRES_PASSWORD, PG_PASSWORD, PGPASSWORD
    Database: DATABASE_NAME, DATABASE_DB, DB_DATABASE, DB_NAME, POSTGRES_DB, PG_DATABASE, PGDATABASE

Examples:
    pgc                             Use default .env file
    pgc -e .env.staging             Use .env.staging file
    pgc -e .env.production          Use .env.production file
    pgc --no-env                    Use shell environment variables
    pgc -d                          Show debug output
    pgc "SELECT 1"                  Execute SQL command directly
    pgc -- -c "SELECT 1"           Execute SQL command (explicit)
    pgc -- --help                  Show psql help

Note:
    - Script will error if specified .env file is not found
    - Missing environment variables will be omitted (no error)
    - If URL is found, individual host/port/user/password/database variables are ignored
    - Connects using psql with PostgreSQL environment variables
    - SQL commands can be passed directly as arguments or after --
    - Everything after -- is passed directly to psql
EOF
}

load_env_file() {
    local env_file="$1"
    
    if [[ ! -f "$env_file" ]]; then
        echo "Error: Environment file '$env_file' not found"
        exit 1
    fi
    
    # Read .env file and export variables
    while IFS= read -r line || [[ -n "$line" ]]; do
        # Skip empty lines and comments
        [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
        
        # Extract key=value pairs
        if [[ "$line" =~ ^[[:space:]]*([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
            local key="${BASH_REMATCH[1]}"
            local value="${BASH_REMATCH[2]}"
            
            # Remove surrounding quotes if present
            value="${value#\"}"
            value="${value%\"}"
            value="${value#\'}"
            value="${value%\'}"
            
            export "$key=$value"
        fi
    done < "$env_file"
}

get_variable_by_priority() {
    local var_name="$1"
    local debug="$2"
    shift 2
    local priority_list=("$@")
    
    for var in "${priority_list[@]}"; do
        if [[ -n "${!var}" ]]; then
            echo "${!var}"
            if [[ "$debug" == "true" ]]; then
                if [[ "$var_name" == "password" ]]; then
                    echo "Using $var: $(mask_password "${!var}")" >&2
                else
                    echo "Using $var: ${!var}" >&2
                fi
            fi
            return
        fi
    done
}

mask_password() {
    local password="$1"
    if [[ -z "$password" ]]; then
        echo "no password"
    elif [[ "$password" == "" ]]; then
        echo "empty password"
    else
        echo "****"
    fi
}

connect_postgres() {
    local debug="$1"
    shift
    local psql_args=("$@")
    
    if [[ "$debug" == "true" ]]; then
        echo "Loading PostgreSQL connection variables:" >&2
    fi
    
    # URL priority: DATABASE_URL, DB_URL, POSTGRES_URL, POSTGRESQL_URL, PG_URL
    local url_vars=(DATABASE_URL DB_URL POSTGRES_URL POSTGRESQL_URL PG_URL)
    local pg_url
    pg_url=$(get_variable_by_priority "url" "$debug" "${url_vars[@]}")
    if [[ -n "$pg_url" ]]; then
        if [[ "$debug" == "true" ]]; then
            echo "Using PostgreSQL URL (ignoring individual variables)" >&2
            echo "" >&2
        fi
        psql "$pg_url" "${psql_args[@]}"
        return
    fi
    
    # Host priority: DATABASE_HOST, DB_HOST, POSTGRES_HOST, PG_HOST, PGHOST
    local host_vars=(DATABASE_HOST DB_HOST POSTGRES_HOST PG_HOST PGHOST)
    local pg_host
    pg_host=$(get_variable_by_priority "host" "$debug" "${host_vars[@]}")
    if [[ -n "$pg_host" ]]; then
        export PGHOST="$pg_host"
    elif [[ "$debug" == "true" ]]; then
        echo "No host variable found" >&2
    fi
    
    # Port priority: DATABASE_PORT, DB_PORT, POSTGRES_PORT, PG_PORT, PGPORT
    local port_vars=(DATABASE_PORT DB_PORT POSTGRES_PORT PG_PORT PGPORT)
    local pg_port
    pg_port=$(get_variable_by_priority "port" "$debug" "${port_vars[@]}")
    if [[ -n "$pg_port" ]]; then
        export PGPORT="$pg_port"
    elif [[ "$debug" == "true" ]]; then
        echo "No port variable found" >&2
    fi
    
    # User priority: DATABASE_USERNAME, DATABASE_USER, DB_USER, DB_USERNAME, POSTGRES_USER, PG_USER, PGUSER
    local user_vars=(DATABASE_USERNAME DATABASE_USER DB_USER DB_USERNAME POSTGRES_USER PG_USER PGUSER)
    local pg_user
    pg_user=$(get_variable_by_priority "user" "$debug" "${user_vars[@]}")
    if [[ -n "$pg_user" ]]; then
        export PGUSER="$pg_user"
    elif [[ "$debug" == "true" ]]; then
        echo "No user variable found" >&2
    fi
    
    # Password priority: DATABASE_PASSWORD, DB_PASSWORD, POSTGRES_PASSWORD, PG_PASSWORD, PGPASSWORD
    local password_vars=(DATABASE_PASSWORD DB_PASSWORD POSTGRES_PASSWORD PG_PASSWORD PGPASSWORD)
    local pg_password
    pg_password=$(get_variable_by_priority "password" "$debug" "${password_vars[@]}")
    if [[ -n "$pg_password" ]]; then
        export PGPASSWORD="$pg_password"
    elif [[ "$debug" == "true" ]]; then
        echo "No password variable found" >&2
    fi
    
    # Database priority: DATABASE_NAME, DATABASE_DB, DB_DATABASE, DB_NAME, POSTGRES_DB, PG_DATABASE, PGDATABASE
    local db_vars=(DATABASE_NAME DATABASE_DB DB_DATABASE DB_NAME POSTGRES_DB PG_DATABASE PGDATABASE)
    local pg_database
    pg_database=$(get_variable_by_priority "database" "$debug" "${db_vars[@]}")
    if [[ -n "$pg_database" ]]; then
        export PGDATABASE="$pg_database"
    elif [[ "$debug" == "true" ]]; then
        echo "No database variable found" >&2
    fi
    
    if [[ "$debug" == "true" ]]; then
        echo "" >&2
    fi
    # Execute psql with the environment variables and any additional arguments
    psql "${psql_args[@]}"
}

main() {
    local env_file=".env"
    local use_shell_env="false"
    local debug="false"
    local psql_args=()
    local sql_command=""
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            -e|--env-file)
                env_file="$2"
                shift 2
                ;;
            --no-env)
                use_shell_env="true"
                shift
                ;;
            -d|--debug)
                debug="true"
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            -v|--version)
                echo "pgc version $VERSION"
                exit 0
                ;;
            --)
                shift
                psql_args=("$@")
                break
                ;;
            -*)
                echo "Unknown option: $1"
                usage
                exit 1
                ;;
            *)
                # First non-option argument is treated as SQL command
                sql_command="$1"
                shift
                
                # Check if next argument is --
                if [[ $# -gt 0 && "$1" == "--" ]]; then
                    shift
                    psql_args=("$@")
                else
                    # Any remaining arguments are treated as additional SQL or psql args
                    psql_args=("$@")
                fi
                break
                ;;
        esac
    done
    
    # If we have a SQL command, convert it to -c format
    if [[ -n "$sql_command" ]]; then
        psql_args=("-c" "$sql_command" "${psql_args[@]}")
    fi
    
    if [[ "$use_shell_env" == "true" ]]; then
        if [[ "$debug" == "true" ]]; then
            echo "Using shell environment variables (skipping .env file)" >&2
        fi
    else
        load_env_file "$env_file"
    fi
    
    connect_postgres "$debug" "${psql_args[@]}"
}

main "$@"
