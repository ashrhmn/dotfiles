#!/bin/bash

set -e

VERSION="1.0.0"

usage() {
    cat << EOF
Usage: pgc [OPTIONS] [SQL_COMMAND | -- PSQL_ARGS...]
       pgc --import <csv_file> <table_name> [IMPORT_OPTIONS]

Connect to PostgreSQL using environment variables from .env file

Options:
    -e, --env-file <file>    Specify custom .env file (default: .env if exists)
    --pgcli                 Use pgcli instead of psql
    --no-pager              Disable pager (add --pset pager=off flag)
    --json                  Output results as JSON array (auto-disables pager)
    --csv                   Output results as CSV (auto-disables pager)
    -w, --write             Allow write operations (default is read-only)
    -d, --debug             Show debug output for connection variables
    -h, --help              Show this help message
    -v, --version           Show version information

Import Options (used with --import):
    --import <file> <table>  Import CSV file into table (auto-enables write mode)
    --header                CSV has header row (default: true)
    --no-header             CSV has no header row
    --delimiter <char>      Field delimiter (default: ',')
    --null-string <str>     String representing NULL (default: empty string)
    --truncate              Truncate table before import
    --columns <list>        Specify column names (e.g., "id,name,email")

Environment Variables (in priority order):
    URL:      DATABASE_URL, DB_URL, POSTGRES_URL, POSTGRESQL_URL, PG_URL
    Host:     DATABASE_HOST, DB_HOST, POSTGRES_HOST, PG_HOST, PGHOST
    Port:     DATABASE_PORT, DB_PORT, POSTGRES_PORT, PG_PORT, PGPORT
    User:     DATABASE_USERNAME, DATABASE_USER, DB_USER, DB_USERNAME, POSTGRES_USER, PG_USER, PGUSER
    Password: DATABASE_PASSWORD, DB_PASSWORD, POSTGRES_PASSWORD, PG_PASSWORD, PGPASSWORD
    Database: DATABASE_NAME, DATABASE_DB, DB_DATABASE, DB_NAME, POSTGRES_DB, PG_DATABASE, PGDATABASE

Environment Priority:
    1. Custom .env file specified with -e flag (errors if not found)
    2. .env file in current directory (used if exists)
    3. Shell environment variables (fallback)

Examples:
    pgc                               Open interactive session (read-only)
    pgc "SELECT * FROM users"         Execute query (read-only)
    pgc --json "SELECT * FROM users"  Get results as JSON array
    pgc --csv "SELECT * FROM users"   Get results as CSV
    pgc -w "UPDATE users SET ..."     Execute write query
    pgc -e .env.production            Use .env.production file
    pgc --pgcli                       Use pgcli instead of psql
    pgc -d                            Show debug output
    pgc -- --help                     Show psql help

Import Examples:
    pgc --import users.csv users                       Import CSV with header
    pgc --import data.csv products --no-header         Import without header
    pgc --import data.csv logs --truncate              Truncate then import
    pgc --import data.tsv users --delimiter $'\t'      Import TSV file
    pgc --import data.csv users --columns "id,name"    Specify columns

Note:
    - Default mode is read-only to prevent accidental writes
    - Use -w or --write to allow INSERT/UPDATE/DELETE/DROP operations
    - If URL is found, individual host/port/user/password/database variables are ignored
    - Everything after -- is passed directly to psql
EOF
}

load_env_file() {
    local env_file="$1"
    local explicit="$2"

    if [[ ! -f "$env_file" ]]; then
        if [[ "$explicit" == "true" ]]; then
            echo "Error: Environment file '$env_file' not found"
            exit 1
        fi
        return 0
    fi

    # Read .env file and export variables
    while IFS= read -r line || [[ -n "$line" ]]; do
        # Skip empty lines and comments
        [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

        # Extract key=value pairs
        if [[ "$line" =~ ^[[:space:]]*([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
            local key="${BASH_REMATCH[1]}"
            local value="${BASH_REMATCH[2]}"

            # Remove surrounding quotes if present
            value="${value#\"}"
            value="${value%\"}"
            value="${value#\'}"
            value="${value%\'}"

            export "$key=$value"
        fi
    done < "$env_file"
}

get_variable_by_priority() {
    local var_name="$1"
    local debug="$2"
    shift 2
    local priority_list=("$@")
    
    for var in "${priority_list[@]}"; do
        if [[ -n "${!var}" ]]; then
            echo "${!var}"
            if [[ "$debug" == "true" ]]; then
                if [[ "$var_name" == "password" ]]; then
                    echo "Using $var: $(mask_password "${!var}")" >&2
                else
                    echo "Using $var: ${!var}" >&2
                fi
            fi
            return
        fi
    done
}

mask_password() {
    local password="$1"
    if [[ -z "$password" ]]; then
        echo "no password"
    elif [[ "$password" == "" ]]; then
        echo "empty password"
    else
        echo "****"
    fi
}

setup_pg_connection_vars() {
    local debug="$1"

    if [[ "$debug" == "true" ]]; then
        echo "Loading PostgreSQL connection variables:" >&2
    fi

    # URL priority: DATABASE_URL, DB_URL, POSTGRES_URL, POSTGRESQL_URL, PG_URL
    local url_vars=(DATABASE_URL DB_URL POSTGRES_URL POSTGRESQL_URL PG_URL)
    local pg_url
    pg_url=$(get_variable_by_priority "url" "$debug" "${url_vars[@]}")
    if [[ -n "$pg_url" ]]; then
        if [[ "$debug" == "true" ]]; then
            echo "Using PostgreSQL URL (ignoring individual variables)" >&2
            echo "" >&2
        fi
        echo "$pg_url"
        return
    fi

    # Host priority: DATABASE_HOST, DB_HOST, POSTGRES_HOST, PG_HOST, PGHOST
    local host_vars=(DATABASE_HOST DB_HOST POSTGRES_HOST PG_HOST PGHOST)
    local pg_host
    pg_host=$(get_variable_by_priority "host" "$debug" "${host_vars[@]}")
    if [[ -n "$pg_host" ]]; then
        export PGHOST="$pg_host"
    elif [[ "$debug" == "true" ]]; then
        echo "No host variable found" >&2
    fi

    # Port priority: DATABASE_PORT, DB_PORT, POSTGRES_PORT, PG_PORT, PGPORT
    local port_vars=(DATABASE_PORT DB_PORT POSTGRES_PORT PG_PORT PGPORT)
    local pg_port
    pg_port=$(get_variable_by_priority "port" "$debug" "${port_vars[@]}")
    if [[ -n "$pg_port" ]]; then
        export PGPORT="$pg_port"
    elif [[ "$debug" == "true" ]]; then
        echo "No port variable found" >&2
    fi

    # User priority: DATABASE_USERNAME, DATABASE_USER, DB_USER, DB_USERNAME, POSTGRES_USER, PG_USER, PGUSER
    local user_vars=(DATABASE_USERNAME DATABASE_USER DB_USER DB_USERNAME POSTGRES_USER PG_USER PGUSER)
    local pg_user
    pg_user=$(get_variable_by_priority "user" "$debug" "${user_vars[@]}")
    if [[ -n "$pg_user" ]]; then
        export PGUSER="$pg_user"
    elif [[ "$debug" == "true" ]]; then
        echo "No user variable found" >&2
    fi

    # Password priority: DATABASE_PASSWORD, DB_PASSWORD, POSTGRES_PASSWORD, PG_PASSWORD, PGPASSWORD
    local password_vars=(DATABASE_PASSWORD DB_PASSWORD POSTGRES_PASSWORD PG_PASSWORD PGPASSWORD)
    local pg_password
    pg_password=$(get_variable_by_priority "password" "$debug" "${password_vars[@]}")
    if [[ -n "$pg_password" ]]; then
        export PGPASSWORD="$pg_password"
    elif [[ "$debug" == "true" ]]; then
        echo "No password variable found" >&2
    fi

    # Database priority: DATABASE_NAME, DATABASE_DB, DB_DATABASE, DB_NAME, POSTGRES_DB, PG_DATABASE, PGDATABASE
    local db_vars=(DATABASE_NAME DATABASE_DB DB_DATABASE DB_NAME POSTGRES_DB PG_DATABASE PGDATABASE)
    local pg_database
    pg_database=$(get_variable_by_priority "database" "$debug" "${db_vars[@]}")
    if [[ -n "$pg_database" ]]; then
        export PGDATABASE="$pg_database"
    elif [[ "$debug" == "true" ]]; then
        echo "No database variable found" >&2
    fi

    if [[ "$debug" == "true" ]]; then
        echo "" >&2
    fi
}

connect_postgres() {
    local debug="$1"
    local use_pgcli="$2"
    local no_pager="$3"
    shift 3
    local psql_args=("$@")

    # Setup connection variables and get URL if available
    local pg_url
    pg_url=$(setup_pg_connection_vars "$debug")

    # If URL is available, use it directly
    if [[ -n "$pg_url" ]]; then
        if [[ "$use_pgcli" == "true" ]]; then
            pgcli "$pg_url" "${psql_args[@]}"
        else
            if [[ "$no_pager" == "true" ]]; then
                psql "$pg_url" --pset pager=off "${psql_args[@]}"
            else
                psql "$pg_url" "${psql_args[@]}"
            fi
        fi
        return
    fi

    # Otherwise use environment variables (already exported by setup_pg_connection_vars)
    if [[ "$use_pgcli" == "true" ]]; then
        pgcli "${psql_args[@]}"
    else
        if [[ "$no_pager" == "true" ]]; then
            psql --pset pager=off "${psql_args[@]}"
        else
            psql "${psql_args[@]}"
        fi
    fi
}

import_csv() {
    local csv_file="$1"
    local table_name="$2"
    local has_header="$3"
    local delimiter="$4"
    local null_string="$5"
    local truncate_table="$6"
    local columns="$7"
    local debug="$8"
    local use_pgcli="$9"
    local env_file="${10}"
    local env_file_explicit="${11}"

    # Validate CSV file exists
    if [[ ! -f "$csv_file" ]]; then
        echo "Error: CSV file '$csv_file' not found"
        exit 1
    fi

    # Get absolute path for CSV file
    csv_file=$(realpath "$csv_file")

    # Build COPY options
    local copy_options="FORMAT csv"

    if [[ "$has_header" == "true" ]]; then
        copy_options="$copy_options, HEADER true"
    fi

    if [[ -n "$delimiter" ]]; then
        copy_options="$copy_options, DELIMITER '$delimiter'"
    fi

    if [[ -n "$null_string" ]]; then
        copy_options="$copy_options, NULL '$null_string'"
    fi

    # Build column list
    local column_list=""
    if [[ -n "$columns" ]]; then
        column_list="($columns)"
    fi

    # Load environment file
    load_env_file "$env_file" "$env_file_explicit"

    # Setup PostgreSQL connection variables
    local pg_url
    pg_url=$(setup_pg_connection_vars "$debug")

    # Build psql command for truncate if needed
    if [[ "$truncate_table" == "true" ]]; then
        echo "Truncating table '$table_name'..."
        local truncate_cmd="TRUNCATE TABLE $table_name;"
        if [[ "$use_pgcli" == "true" ]]; then
            echo "Error: --import with --truncate is not supported with --pgcli"
            exit 1
        fi

        # Execute truncate
        export PGOPTIONS=""  # Remove read-only mode
        if [[ -n "$pg_url" ]]; then
            psql "$pg_url" -c "$truncate_cmd" --pset pager=off
        else
            psql -c "$truncate_cmd" --pset pager=off
        fi
        if [[ $? -ne 0 ]]; then
            echo "Error: Failed to truncate table"
            exit 1
        fi
    fi

    # Build \copy command
    local copy_cmd="\copy $table_name$column_list FROM '$csv_file' WITH ($copy_options)"

    if [[ "$debug" == "true" ]]; then
        echo "Executing: $copy_cmd" >&2
    fi

    echo "Importing '$csv_file' into table '$table_name'..."

    # Execute import
    export PGOPTIONS=""  # Remove read-only mode

    if [[ "$use_pgcli" == "true" ]]; then
        echo "Error: --import is not supported with --pgcli (use psql)"
        exit 1
    fi

    # Execute the \copy command
    if [[ -n "$pg_url" ]]; then
        psql "$pg_url" -c "$copy_cmd" --pset pager=off
    else
        psql -c "$copy_cmd" --pset pager=off
    fi

    if [[ $? -eq 0 ]]; then
        echo "Import completed successfully"
    else
        echo "Error: Import failed"
        exit 1
    fi
}

main() {
    local env_file=".env"
    local env_file_explicit="false"
    local use_pgcli="false"
    local no_pager="false"
    local json_output="false"
    local csv_output="false"
    local allow_write="false"
    local debug="false"
    local psql_args=()
    local sql_command=""

    # Import-specific variables
    local import_mode="false"
    local import_file=""
    local import_table=""
    local import_header="true"
    local import_delimiter=""
    local import_null_string=""
    local import_truncate="false"
    local import_columns=""

    while [[ $# -gt 0 ]]; do
        case $1 in
            -e|--env-file)
                env_file="$2"
                env_file_explicit="true"
                shift 2
                ;;
            --import)
                import_mode="true"
                import_file="$2"
                import_table="$3"
                if [[ -z "$import_file" || -z "$import_table" ]]; then
                    echo "Error: --import requires <csv_file> and <table_name>"
                    usage
                    exit 1
                fi
                shift 3
                ;;
            --header)
                import_header="true"
                shift
                ;;
            --no-header)
                import_header="false"
                shift
                ;;
            --delimiter)
                import_delimiter="$2"
                shift 2
                ;;
            --null-string)
                import_null_string="$2"
                shift 2
                ;;
            --truncate)
                import_truncate="true"
                shift
                ;;
            --columns)
                import_columns="$2"
                shift 2
                ;;
            --pgcli)
                use_pgcli="true"
                shift
                ;;
            --no-pager)
                no_pager="true"
                shift
                ;;
            --json)
                json_output="true"
                no_pager="true"
                shift
                ;;
            --csv)
                csv_output="true"
                no_pager="true"
                shift
                ;;
            -w|--write)
                allow_write="true"
                shift
                ;;
            -d|--debug)
                debug="true"
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            -v|--version)
                echo "pgc version $VERSION"
                exit 0
                ;;
            --)
                shift
                psql_args=("$@")
                break
                ;;
            -*)
                echo "Unknown option: $1"
                usage
                exit 1
                ;;
            *)
                # First non-option argument is treated as SQL command
                sql_command="$1"
                shift

                # Check if next argument is --
                if [[ $# -gt 0 && "$1" == "--" ]]; then
                    shift
                    psql_args=("$@")
                else
                    # Any remaining arguments are treated as additional SQL or psql args
                    psql_args=("$@")
                fi
                break
                ;;
        esac
    done

    # Handle import mode
    if [[ "$import_mode" == "true" ]]; then
        import_csv "$import_file" "$import_table" "$import_header" "$import_delimiter" \
                   "$import_null_string" "$import_truncate" "$import_columns" "$debug" \
                   "$use_pgcli" "$env_file" "$env_file_explicit"
        exit 0
    fi

    # If we have a SQL command, convert it to -c format
    if [[ -n "$sql_command" ]]; then
        if [[ "$json_output" == "true" ]]; then
            # Wrap query with json_agg for JSON output
            sql_command="SELECT COALESCE(json_agg(row_to_json(t)), '[]'::json) FROM (${sql_command}) t"
            psql_args=("-t" "-A" "-c" "$sql_command" "${psql_args[@]}")
        elif [[ "$csv_output" == "true" ]]; then
            psql_args=("--csv" "-c" "$sql_command" "${psql_args[@]}")
        else
            psql_args=("-c" "$sql_command" "${psql_args[@]}")
        fi
    fi

    # Set read-only mode unless --write is specified
    if [[ "$allow_write" == "false" ]]; then
        export PGOPTIONS="-c default_transaction_read_only=on"
    fi

    # Load environment file with priority:
    # 1. Explicitly specified file (error if not found)
    # 2. .env in current directory (use if exists)
    # 3. Shell environment variables (fallback)
    load_env_file "$env_file" "$env_file_explicit"

    connect_postgres "$debug" "$use_pgcli" "$no_pager" "${psql_args[@]}"
}

main "$@"
