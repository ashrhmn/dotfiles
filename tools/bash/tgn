#!/bin/bash

set -e

VERSION="2.0.0"
TGN_BASE_URL="https://tgn.ashrhmn.com"
TGN_NOTIFY_URL="$TGN_BASE_URL/v1/notify"
TGN_FILE_URL="$TGN_BASE_URL/v1/file"
TGN_PROMPT_URL="$TGN_BASE_URL/v1/prompt"
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/tgn"
CONFIG_FILE="$CONFIG_DIR/config"

DEBUG="false"
MAX_MESSAGE_LENGTH=3500
DEFAULT_TIMEOUT=172800  # 48 hours

usage() {
    cat << EOF
Usage: tgn [OPTIONS] <message|file>
       tgn [OPTIONS] -x <command>
       <command> | tgn [OPTIONS]
       tgn login

Send notifications to Telegram via TGN service.

Commands:
    login               Interactively configure and store token

Options:
    -t, --title <text>      Title prefix shown in brackets, e.g. [Deploy]
    -l, --level <level>     Severity level: info, warn, error
    -p, --parse-mode <mode> Telegram parse mode: HTML or MarkdownV2
    -x, --exec <command>    Run command and send its output as notification
    -i, --interval <secs>   With -x, repeat command every N seconds (min: 1)
    -b, --buttons <list>    Comma-separated button labels for interactive prompt
    -f, --free-input        Allow free-form text input (requires -b)
    -z, --zip <file> <args> Create zip file from specified args and send
    --timeout <secs>        Timeout for prompt response (default: 48h)
    -d, --debug             Show debug output (request payload, response)
    -h, --help              Show this help message
    -v, --version           Show version information

Environment Variables:
    TGN_TOKEN               Device token (takes priority over config file)

Configuration:
    Token is read from TGN_TOKEN env var, or from $CONFIG_FILE
    Run 'tgn login' to configure token interactively.

Behavior:
    - If argument is an existing file, sends the file
    - If message exceeds $MAX_MESSAGE_LENGTH chars, sends as file
    - Pipe support: echo "msg" | tgn

Examples:
    tgn "Build completed"
    tgn ./report.log                      Send file
    docker logs app | tgn -t logs         Pipe (auto-file if long)
    tgn -b "yes,no" "Deploy to prod?"     Interactive prompt
    tgn -b "approve,reject" -f "Review?"  Prompt with free text option
    response=\$(tgn -b "y,n" "Continue?") Capture response
    tgn -z dots.zip -r nvim tmux zshrc    Create zip and send

Setup:
    1. Message @tgnnnn_bot on Telegram
    2. Send /start to register
    3. Send /add mydevice to create a device and get a token
    4. Run: tgn login
EOF
}

debug() {
    if [[ "$DEBUG" == "true" ]]; then
        echo "[DEBUG] $*" >&2
    fi
}

get_token() {
    if [[ -n "$TGN_TOKEN" ]]; then
        debug "Using token from TGN_TOKEN env var"
        echo "$TGN_TOKEN"
        return 0
    fi

    if [[ -f "$CONFIG_FILE" ]]; then
        local token
        token=$(grep -E "^TGN_TOKEN=" "$CONFIG_FILE" 2>/dev/null | cut -d'=' -f2-)
        if [[ -n "$token" ]]; then
            debug "Using token from $CONFIG_FILE"
            echo "$token"
            return 0
        fi
    fi

    return 1
}

do_login() {
    echo "TGN Login"
    echo "---------"
    echo ""
    echo "To get a token:"
    echo "  1. Message @tgnnnn_bot on Telegram"
    echo "  2. Send /start to register"
    echo "  3. Send /add <device_name> to create a device"
    echo ""
    read -rsp "Enter your TGN token: " token
    echo

    if [[ -z "$token" ]]; then
        echo "Error: Token cannot be empty"
        exit 1
    fi

    mkdir -p "$CONFIG_DIR"
    chmod 700 "$CONFIG_DIR"
    echo "TGN_TOKEN=$token" > "$CONFIG_FILE"
    chmod 600 "$CONFIG_FILE"

    echo ""
    echo "Token saved to $CONFIG_FILE"
    echo "You can now send notifications with: tgn \"Your message\""
}

send_file() {
    local file_path="$1"
    local caption="$2"
    local parse_mode="$3"

    local token
    if ! token=$(get_token); then
        echo "Error: No token configured" >&2
        exit 1
    fi

    debug "Sending file: $file_path"

    local curl_args=(-s -w "\n%{http_code}" -X POST "$TGN_FILE_URL"
        -H "Authorization: Bearer $token"
        -F "file=@$file_path")

    if [[ -n "$caption" ]]; then
        curl_args+=(-F "caption=$caption")
    fi

    if [[ -n "$parse_mode" ]]; then
        local normalized_mode
        case "${parse_mode,,}" in
            html) normalized_mode="HTML" ;;
            markdownv2|markdown) normalized_mode="MarkdownV2" ;;
            *) normalized_mode="$parse_mode" ;;
        esac
        curl_args+=(-F "parseMode=$normalized_mode")
    fi

    local response http_code body
    response=$(curl "${curl_args[@]}")
    http_code=$(echo "$response" | tail -n1)
    body=$(echo "$response" | sed '$d')

    debug "HTTP Status: $http_code"
    debug "Response: $body"

    handle_response "$http_code" "$body"
}

send_notification() {
    local message="$1"
    local title="$2"
    local level="$3"
    local parse_mode="$4"

    local token
    if ! token=$(get_token); then
        echo "Error: No token configured" >&2
        exit 1
    fi

    local json_payload="{\"message\":$(printf '%s' "$message" | jq -Rs .)}"

    if [[ -n "$title" ]]; then
        json_payload=$(echo "$json_payload" | jq --arg t "$title" '. + {title: $t}')
    fi

    if [[ -n "$level" ]]; then
        json_payload=$(echo "$json_payload" | jq --arg l "$level" '. + {level: $l}')
    fi

    if [[ -n "$parse_mode" ]]; then
        local normalized_mode
        case "${parse_mode,,}" in
            html) normalized_mode="HTML" ;;
            markdownv2|markdown) normalized_mode="MarkdownV2" ;;
            *) normalized_mode="$parse_mode" ;;
        esac
        json_payload=$(echo "$json_payload" | jq --arg p "$normalized_mode" '. + {parseMode: $p}')
    fi

    debug "URL: $TGN_NOTIFY_URL"
    debug "Payload: $json_payload"

    local response http_code body
    response=$(curl -s -w "\n%{http_code}" -X POST "$TGN_NOTIFY_URL" \
        -H "Authorization: Bearer $token" \
        -H "Content-Type: application/json" \
        -d "$json_payload")

    http_code=$(echo "$response" | tail -n1)
    body=$(echo "$response" | sed '$d')

    debug "HTTP Status: $http_code"
    debug "Response: $body"

    handle_response "$http_code" "$body"
}

send_prompt() {
    local message="$1"
    local buttons="$2"
    local free_input="$3"
    local parse_mode="$4"
    local timeout="$5"

    local token
    if ! token=$(get_token); then
        echo "Error: No token configured" >&2
        exit 1
    fi

    # Build buttons array
    local buttons_json="[]"
    if [[ -n "$buttons" ]]; then
        buttons_json=$(echo "$buttons" | tr ',' '\n' | jq -R . | jq -s .)
    fi

    local json_payload
    json_payload=$(jq -n \
        --arg msg "$message" \
        --argjson btns "$buttons_json" \
        '{message: $msg, buttons: $btns}')

    if [[ "$free_input" == "true" ]]; then
        json_payload=$(echo "$json_payload" | jq '. + {freeInput: true}')
    fi

    if [[ -n "$parse_mode" ]]; then
        local normalized_mode
        case "${parse_mode,,}" in
            html) normalized_mode="HTML" ;;
            markdownv2|markdown) normalized_mode="MarkdownV2" ;;
            *) normalized_mode="$parse_mode" ;;
        esac
        json_payload=$(echo "$json_payload" | jq --arg p "$normalized_mode" '. + {parseMode: $p}')
    fi

    debug "URL: $TGN_PROMPT_URL"
    debug "Payload: $json_payload"

    local response http_code body
    response=$(curl -s -w "\n%{http_code}" -X POST "$TGN_PROMPT_URL" \
        -H "Authorization: Bearer $token" \
        -H "Content-Type: application/json" \
        -d "$json_payload")

    http_code=$(echo "$response" | tail -n1)
    body=$(echo "$response" | sed '$d')

    debug "HTTP Status: $http_code"
    debug "Response: $body"

    if [[ "$http_code" != "200" ]]; then
        handle_response "$http_code" "$body"
        return 1
    fi

    local prompt_id
    prompt_id=$(echo "$body" | jq -r '.promptId')

    if [[ -z "$prompt_id" || "$prompt_id" == "null" ]]; then
        echo "Error: Failed to get prompt ID" >&2
        return 1
    fi

    debug "Prompt ID: $prompt_id"
    echo "Waiting for response..." >&2

    # Poll with exponential backoff
    local delay=1
    local max_delay=15
    local elapsed=0
    local start_time
    start_time=$(date +%s)

    while true; do
        local now
        now=$(date +%s)
        elapsed=$((now - start_time))

        if [[ $elapsed -ge $timeout ]]; then
            echo "Error: Timeout waiting for response" >&2
            return 1
        fi

        response=$(curl -s -w "\n%{http_code}" \
            "$TGN_PROMPT_URL/$prompt_id" \
            -H "Authorization: Bearer $token")

        http_code=$(echo "$response" | tail -n1)
        body=$(echo "$response" | sed '$d')

        debug "Poll response: $body"

        if [[ "$http_code" != "200" ]]; then
            handle_response "$http_code" "$body"
            return 1
        fi

        local status
        status=$(echo "$body" | jq -r '.status')

        case "$status" in
            answered)
                local user_response
                user_response=$(echo "$body" | jq -r '.response')
                echo "$user_response"
                return 0
                ;;
            expired)
                echo "Error: Prompt expired" >&2
                return 1
                ;;
            pending)
                debug "Still pending, next check in ${delay}s"
                sleep "$delay"
                delay=$((delay * 2))
                [[ $delay -gt $max_delay ]] && delay=$max_delay
                ;;
            *)
                echo "Error: Unknown status: $status" >&2
                return 1
                ;;
        esac
    done
}

handle_response() {
    local http_code="$1"
    local body="$2"

    case "$http_code" in
        200)
            if echo "$body" | jq -e '.ok' &>/dev/null; then
                echo "Notification sent" >&2
                return 0
            else
                echo "$body" >&2
                return 0
            fi
            ;;
        400)
            echo "Error: Bad request" >&2
            if [[ -n "$body" ]]; then
                echo "$body" >&2
            fi
            return 1
            ;;
        401)
            echo "Error: Invalid or missing token" >&2
            return 1
            ;;
        403)
            echo "Error: Token has been revoked" >&2
            return 1
            ;;
        429)
            echo "Error: Rate limit exceeded" >&2
            return 1
            ;;
        502)
            echo "Error: Telegram API error" >&2
            if [[ -n "$body" ]]; then
                echo "$body" >&2
            fi
            return 1
            ;;
        *)
            echo "Error: Request failed with status $http_code" >&2
            if [[ -n "$body" ]]; then
                echo "$body" >&2
            fi
            return 1
            ;;
    esac
}

send_message_or_file() {
    local message="$1"
    local title="$2"
    local level="$3"
    local parse_mode="$4"

    local msg_length=${#message}

    if [[ $msg_length -gt $MAX_MESSAGE_LENGTH ]]; then
        debug "Message too long ($msg_length chars), sending as file"
        local tmp_file
        tmp_file=$(mktemp --suffix=.txt)
        echo "$message" > "$tmp_file"

        local caption="${title:-Output}"
        if [[ -n "$level" ]]; then
            caption="[$level] $caption"
        fi

        send_file "$tmp_file" "$caption" "$parse_mode"
        local result=$?
        rm -f "$tmp_file"
        return $result
    else
        send_notification "$message" "$title" "$level" "$parse_mode"
    fi
}

create_zip_and_send() {
    local zip_name="$1"
    shift
    local zip_args=("$@")

    if [[ -z "$zip_name" ]]; then
        echo "Error: -z/--zip requires a filename" >&2
        exit 1
    fi

    if [[ ${#zip_args[@]} -eq 0 ]]; then
        echo "Error: -z/--zip requires files/directories to zip" >&2
        exit 1
    fi

    local tmp_zip="/tmp/$zip_name"
    debug "Creating zip: $tmp_zip with args: ${zip_args[*]}"

    if ! zip -q "$tmp_zip" "${zip_args[@]}" 2>&1; then
        echo "Error: Failed to create zip file" >&2
        exit 1
    fi

    debug "Zip created successfully: $tmp_zip"
    send_file "$tmp_zip" ""
    local result=$?

    rm -f "$tmp_zip"
    debug "Removed temporary zip: $tmp_zip"

    return $result
}

run_command_and_notify() {
    local cmd="$1"
    local title="$2"
    local level="$3"
    local parse_mode="$4"
    local interval="$5"

    if [[ -n "$interval" ]]; then
        if [[ "$interval" -lt 1 ]]; then
            echo "Error: Interval must be at least 1 second"
            exit 1
        fi
        debug "Running command every ${interval}s: $cmd"
        echo "Running '$cmd' every ${interval}s (Ctrl+C to stop)" >&2
        while true; do
            local output exit_code=0
            output=$(eval "$cmd" 2>&1) || exit_code=$?

            local msg="$output"
            if [[ $exit_code -ne 0 ]]; then
                msg="Exit code: $exit_code"$'\n'"$output"
            fi

            debug "Command output: $msg"
            send_message_or_file "$msg" "$title" "$level" "$parse_mode" || true
            sleep "$interval"
        done
    else
        debug "Running command: $cmd"
        local output exit_code=0
        output=$(eval "$cmd" 2>&1) || exit_code=$?

        local msg="$output"
        if [[ $exit_code -ne 0 ]]; then
            msg="Exit code: $exit_code"$'\n'"$output"
        fi

        debug "Command output: $msg"
        send_message_or_file "$msg" "$title" "$level" "$parse_mode"
    fi
}

main() {
    local title=""
    local level=""
    local parse_mode=""
    local message=""
    local exec_cmd=""
    local interval=""
    local buttons=""
    local free_input="false"
    local timeout="$DEFAULT_TIMEOUT"
    local zip_mode=""
    declare -a zip_args

    if [[ $# -eq 0 ]] && [[ -t 0 ]]; then
        usage
        exit 0
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            login)
                do_login
                exit 0
                ;;
            -t|--title)
                title="$2"
                shift 2
                ;;
            -l|--level)
                level="$2"
                shift 2
                ;;
            -p|--parse-mode)
                parse_mode="$2"
                shift 2
                ;;
            -x|--exec)
                exec_cmd="$2"
                shift 2
                ;;
            -i|--interval)
                interval="$2"
                shift 2
                ;;
            -b|--buttons)
                buttons="$2"
                shift 2
                ;;
            -f|--free-input)
                free_input="true"
                shift
                ;;
            -z|--zip)
                zip_mode="$2"
                shift 2
                # Capture all remaining arguments for zip
                while [[ $# -gt 0 ]]; do
                    zip_args+=("$1")
                    shift
                done
                break
                ;;
            --timeout)
                timeout="$2"
                shift 2
                ;;
            -d|--debug)
                DEBUG="true"
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            -v|--version)
                echo "tgn version $VERSION"
                exit 0
                ;;
            -*)
                echo "Unknown option: $1"
                echo ""
                usage
                exit 1
                ;;
            *)
                message="$1"
                shift
                ;;
        esac
    done

    # Handle zip mode
    if [[ -n "$zip_mode" ]]; then
        create_zip_and_send "$zip_mode" "${zip_args[@]}"
        exit 0
    fi

    # Handle exec mode
    if [[ -n "$exec_cmd" ]]; then
        run_command_and_notify "$exec_cmd" "$title" "$level" "$parse_mode" "$interval"
        exit 0
    fi

    if [[ -n "$interval" ]]; then
        echo "Error: -i/--interval requires -x/--exec"
        exit 1
    fi

    # Read from stdin if no message provided and stdin is piped
    if [[ -z "$message" ]] && [[ ! -t 0 ]]; then
        message=$(cat)
    fi

    if [[ -z "$message" ]]; then
        echo "Error: Message is required"
        echo ""
        usage
        exit 1
    fi

    # Handle prompt mode
    if [[ -n "$buttons" ]] || [[ "$free_input" == "true" ]]; then
        send_prompt "$message" "$buttons" "$free_input" "$parse_mode" "$timeout"
        exit $?
    fi

    # Check if message is a file path
    if [[ -f "$message" ]]; then
        debug "Argument is a file: $message"
        local caption="$title"
        if [[ -n "$level" ]]; then
            if [[ -n "$caption" ]]; then
                caption="[$level] $caption"
            else
                caption="[$level]"
            fi
        fi
        send_file "$message" "$caption" "$parse_mode"
        exit $?
    fi

    # Send as message (auto-file if too long)
    send_message_or_file "$message" "$title" "$level" "$parse_mode"
}

main "$@"
